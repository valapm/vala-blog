<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Advanced Arithmetic in Bitcoin Script | Vala Blog</title><meta name=keywords content="sCrypt"><meta name=description content="In Bitcoin, we are limited to basic arithmetic. Everything available to us in Script is addition, subtraction, multiplication, division, and modulus.
If we want to challenge Ethereum and build Defi applications using automated market makers, compound interest or liquidity mechanisms, this is not enough. Fortunately, there is a way to use what we have available and implement everything we need. We built a library for Vala implementing log, exp, root and pow."><meta name=author content="Merlin"><link rel=canonical href=https://blog.vala.ai/posts/fixmath/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.vala.ai/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://blog.vala.ai/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://blog.vala.ai/favicon.svg><link rel=apple-touch-icon href=https://blog.vala.ai/favicon.svg><link rel=mask-icon href=https://blog.vala.ai/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Advanced Arithmetic in Bitcoin Script"><meta property="og:description" content="In Bitcoin, we are limited to basic arithmetic. Everything available to us in Script is addition, subtraction, multiplication, division, and modulus.
If we want to challenge Ethereum and build Defi applications using automated market makers, compound interest or liquidity mechanisms, this is not enough. Fortunately, there is a way to use what we have available and implement everything we need. We built a library for Vala implementing log, exp, root and pow."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.vala.ai/posts/fixmath/"><meta property="og:image" content="https://blog.vala.ai/spiral.jpeg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-16T11:33:40+03:00"><meta property="article:modified_time" content="2022-10-16T11:33:40+03:00"><meta property="og:site_name" content="Vala Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.vala.ai/spiral.jpeg"><meta name=twitter:title content="Advanced Arithmetic in Bitcoin Script"><meta name=twitter:description content="In Bitcoin, we are limited to basic arithmetic. Everything available to us in Script is addition, subtraction, multiplication, division, and modulus.
If we want to challenge Ethereum and build Defi applications using automated market makers, compound interest or liquidity mechanisms, this is not enough. Fortunately, there is a way to use what we have available and implement everything we need. We built a library for Vala implementing log, exp, root and pow."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.vala.ai/posts/"},{"@type":"ListItem","position":2,"name":"Advanced Arithmetic in Bitcoin Script","item":"https://blog.vala.ai/posts/fixmath/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Advanced Arithmetic in Bitcoin Script","name":"Advanced Arithmetic in Bitcoin Script","description":"In Bitcoin, we are limited to basic arithmetic. Everything available to us in Script is addition, subtraction, multiplication, division, and modulus.\nIf we want to challenge Ethereum and build Defi applications using automated market makers, compound interest or liquidity mechanisms, this is not enough. Fortunately, there is a way to use what we have available and implement everything we need. We built a library for Vala implementing log, exp, root and pow.","keywords":["sCrypt"],"articleBody":"In Bitcoin, we are limited to basic arithmetic. Everything available to us in Script is addition, subtraction, multiplication, division, and modulus.\nIf we want to challenge Ethereum and build Defi applications using automated market makers, compound interest or liquidity mechanisms, this is not enough. Fortunately, there is a way to use what we have available and implement everything we need. We built a library for Vala implementing log, exp, root and pow.\nOne challenge we face is Bitcoin’s lack of floating points. We’ll have to implement everything using fixed-point arithmetic. The next challenge is keeping our script code concise. Even on BSV we don’t want giant transactions for simple mathematics. We will have to make a trade-off between precision and size.\nAll examples will be using sCrypt. We will work with 64-bit fixed-point numbers:\nstatic int precision = 64; static int scale = 18446744073709551616; // 2 ^ precision int fixedPointInt = num \u003c\u003c precision; The key is to approximate the logarithm and exponentiation. From there, we can derive everything else we need. Let’s start with the binary logarithm. This is an approximation for numbers greater than 1.\n/** * Finds the zero-based index of the first one in the binary representation of x. * Accepts numbers scaled by 2**64 (64-bit fixed-point number). * Adapted from https://github.com/paulrberg/prb-math */ static function mostSignificantBit(int x) : int { int msb = 0; if (x \u003e= 340282366920938463463374607431768211456) { // 2^128 x = x \u003e\u003e 128; msb += 128; } if (x \u003e= 18446744073709551616) { // 2^64 x = x \u003e\u003e 64; msb += 64; } // // Several similar lines removed for this example.... // if (x \u003e= 2) { // 2^1 // No need to shift x any more. msb += 1; } return msb; } /** * Calculates the binary logarithm of x. * Accepts and returns scaled by 2**64 (64-bit fixed-point number). * Only works for x greater than 1 \u003c\u003c 64 (log2(1)). * Adapted from https://github.com/paulrberg/prb-math */ static function log2(int x) : int { if (x \u003c scale) { require(false); } // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n). int n = mostSignificantBit(x / scale); // The integer part of the logarithm as a signed 59.18-decimal fixed-point number. The operation can't overflow // because n is maximum 255, scale is 1e18 and sign is either 1 or -1. int result = n * scale; // This is y = x * 2^(-n). int y = x \u003e\u003e n; // If y = 1, the fractional part is zero. if (y != scale) { // Calculate the fractional part via the iterative approximation. // The \"delta \u003e\u003e= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster. loop (64) : i { y = (y * y) / scale; // Is y^2 \u003e 2 and so in the range [2,4)? if (y \u003e= scale \u003c\u003c 1) { // Add the 2^(-m) factor to the logarithm. int delta = scale \u003e\u003e (i + 1); result += delta; // Corresponds to z/2 on Wikipedia. y = y \u003e\u003e 1; } } } return result; } From here, we can easily calculate the logarithm of other bases.\nstatic int ln2 = 12786308645202657280; // log(x) * scale / log2(x) static int ln10 = 5553023288523357184; // log10(x) * scale / log2(x) static function log(int x) : int { return FixMath.log2(x) * FixMath.ln2 / FixMath.scale; } static function log10(int x) : int { return FixMath.log2(x) * FixMath.ln10 / FixMath.scale; } Next up is the exponentiation of base 2. This approximation works between -60 and 192.\n/** * Calculates the binary exponent of x using the binary fraction method. * Accepts and returns scaled by 2**64 (64-bit fixed-point number). * Adapted from https://github.com/paulrberg/prb-math */ static function exp2(int x) : int { if (x \u003e 3541774862152233910272 || x \u003c -1103017633157748883456) { // 192 max value // -59.794705707972522261 min value require(false); } // Start from 0.5 in the 192.64-bit fixed-point format. int result = 0x800000000000000000000000000000000000000000000000; // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows // because the initial result is 2^191 and all magic factors are less than 2^65. if ((x \u0026 0x8000000000000000) \u003e 0) { result = (result * 0x16a09e667f3bcc909) \u003e\u003e 64; } if ((x \u0026 0x4000000000000000) \u003e 0) { result = (result * 0x1306fe0a31b7152df) \u003e\u003e 64; } if ((x \u0026 0x2000000000000000) \u003e 0) { result = (result * 0x1172b83c7d517adce) \u003e\u003e 64; } // // Several similar lines removed for this example.... // if ((x \u0026 0x1) \u003e 0) { result = (result * 0x10000000000000001) \u003e\u003e 64; } // We're doing two things at the same time: // // 1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for // the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191 // rather than 192. // 2. Convert the result to the unsigned 60.18-decimal fixed-point format. // // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\". result = result \u003c\u003c 64; result = result \u003e\u003e (191 - (x \u003e\u003e 64)); return result; } Now, we can easily derive the exponential function.\nstatic int log2e = 26613026195688644608; // Math.floor(Math.log2(Math.E) * 2**64) /** * Accepts and returns scaled by 2**64 (64-bit fixed-point number). */ static function exp(int x) : int { if (x \u003e 2454971259878909673472 || x \u003c -764553562531197616128) { // Max value is 133.084258667509499441 // Min value is -41.446531673892822322 require(false); } return FixMath.exp2((x * log2e) \u003e\u003e 64); } Using exp and log, we can derive root and pow.\nstatic function sqrt(int x) : int { return exp2(log2(x) / 2); } static function root(int x, int base) : int { return exp2((log2(x) \u003c\u003c 64) / base); } static function pow(int base, int exp) : int { return exp2((exp * log2(base)) \u003e\u003e 64); } How big are the Scripts? The exponential function is smallest with only 8kb. The logarithm comes in with 17kb while root and pow require 25kb each as they are using exp and log. At 50 sats per kilobyte as currently offered by Taal, running the root or pow functions would set you back around 6/100 of a cent.\nVala Vala uses exp and log in its automated market maker, namely the Logarithmic Market Scoring Rule. Without this, there could be no liquidity mechanism and the app would be unusable.\nThe library The full library is open sourced on Github and contains a Typescript implementation of the same functions in addition to the sCrypt code so that you can actually generate valid transactions.\nhttps://github.com/valapm/bsv-fixmath\n","wordCount":"1118","inLanguage":"en","image":"https://blog.vala.ai/spiral.jpeg","datePublished":"2022-10-16T11:33:40+03:00","dateModified":"2022-10-16T11:33:40+03:00","author":{"@type":"Person","name":"Merlin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.vala.ai/posts/fixmath/"},"publisher":{"@type":"Organization","name":"Vala Blog","logo":{"@type":"ImageObject","url":"https://blog.vala.ai/favicon.svg"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://blog.vala.ai/ accesskey=h title="  (Alt + H)"><img src=https://blog.vala.ai/favicon.svg alt aria-label=logo height=35></a><div class=logo-switches></div></div><ul id=menu><li><a href=https://blog.vala.ai/index.xml title=rss><span>rss</span></a></li><li><a href=https://blog.vala.ai/tags title=tags><span>tags</span></a></li><li><a href=https://vala.ai title=vala.ai><span>vala.ai</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://docs.vala.ai title=docs><span>docs</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.vala.ai/>Home</a>&nbsp;»&nbsp;<a href=https://blog.vala.ai/posts/>Posts</a></div><h1 class=post-title>Advanced Arithmetic in Bitcoin Script</h1><div class=post-meta><span title='2022-10-16 11:33:40 +0300 +0300'>October 16, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1118 words&nbsp;·&nbsp;Merlin&nbsp;|&nbsp;<a href=https://github.com/valapm/vala-blog/content/posts/fixmath.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://blog.vala.ai/spiral.jpeg alt="logarithmic spiral"></figure><div class=post-content><p>In Bitcoin, we are limited to basic arithmetic. Everything available to us in Script is addition, subtraction, multiplication, division, and modulus.</p><p>If we want to challenge Ethereum and build Defi applications using automated market makers, compound interest or liquidity mechanisms, this is not enough. Fortunately, there is a way to use what we have available and implement everything we need. We built a <a href=https://github.com/valapm/bsv-fixmath>library</a> for Vala implementing <code>log</code>, <code>exp</code>, <code>root</code> and <code>pow</code>.</p><p>One challenge we face is Bitcoin&rsquo;s lack of floating points. We&rsquo;ll have to implement everything using <a href=https://en.wikipedia.org/wiki/Fixed-point_arithmetic>fixed-point arithmetic</a>. The next challenge is keeping our script code concise. Even on BSV we don&rsquo;t want giant transactions for simple mathematics. We will have to make a trade-off between precision and size.</p><p>All examples will be using <a href=https://scrypt.io/>sCrypt</a>. We will work with 64-bit fixed-point numbers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>static</span> <span class=kr>int</span> <span class=nx>precision</span> <span class=o>=</span> <span class=mi>64</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>static</span> <span class=kr>int</span> <span class=nx>scale</span> <span class=o>=</span> <span class=mi>18446744073709551616</span><span class=p>;</span> <span class=c1>// 2 ^ precision
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kr>int</span> <span class=nx>fixedPointInt</span> <span class=o>=</span> <span class=nx>num</span> <span class=o>&lt;&lt;</span> <span class=nx>precision</span><span class=p>;</span>
</span></span></code></pre></div><p>The key is to approximate the logarithm and exponentiation. From there, we can derive everything else we need. Let&rsquo;s start with the binary logarithm. This is an approximation for numbers greater than 1.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>* Finds the zero-based index of the first one in the binary representation of x.
</span></span></span><span class=line><span class=cl><span class=cm>* Accepts numbers scaled by 2**64 (64-bit fixed-point number).
</span></span></span><span class=line><span class=cl><span class=cm>* Adapted from https://github.com/paulrberg/prb-math
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kr>static</span> <span class=kd>function</span> <span class=nx>mostSignificantBit</span><span class=p>(</span><span class=kr>int</span> <span class=nx>x</span><span class=p>)</span> <span class=o>:</span> <span class=kr>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>int</span> <span class=nx>msb</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>x</span> <span class=o>&gt;=</span> <span class=mi>340282366920938463463374607431768211456</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 2^128
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>x</span> <span class=o>=</span> <span class=nx>x</span> <span class=o>&gt;&gt;</span> <span class=mi>128</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>msb</span> <span class=o>+=</span> <span class=mi>128</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>x</span> <span class=o>&gt;=</span> <span class=mi>18446744073709551616</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 2^64
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>x</span> <span class=o>=</span> <span class=nx>x</span> <span class=o>&gt;&gt;</span> <span class=mi>64</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>msb</span> <span class=o>+=</span> <span class=mi>64</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// Several similar lines removed for this example....
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nx>x</span> <span class=o>&gt;=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 2^1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// No need to shift x any more.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>msb</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>msb</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>* Calculates the binary logarithm of x.
</span></span></span><span class=line><span class=cl><span class=cm>* Accepts and returns scaled by 2**64 (64-bit fixed-point number).
</span></span></span><span class=line><span class=cl><span class=cm>* Only works for x greater than 1 &lt;&lt; 64 (log2(1)).
</span></span></span><span class=line><span class=cl><span class=cm>* Adapted from https://github.com/paulrberg/prb-math
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kr>static</span> <span class=kd>function</span> <span class=nx>log2</span><span class=p>(</span><span class=kr>int</span> <span class=nx>x</span><span class=p>)</span> <span class=o>:</span> <span class=kr>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>x</span> <span class=o>&lt;</span> <span class=nx>scale</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>require</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>int</span> <span class=nx>n</span> <span class=o>=</span> <span class=nx>mostSignificantBit</span><span class=p>(</span><span class=nx>x</span> <span class=o>/</span> <span class=nx>scale</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// The integer part of the logarithm as a signed 59.18-decimal fixed-point number. The operation can&#39;t overflow
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// because n is maximum 255, scale is 1e18 and sign is either 1 or -1.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>int</span> <span class=nx>result</span> <span class=o>=</span> <span class=nx>n</span> <span class=o>*</span> <span class=nx>scale</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// This is y = x * 2^(-n).
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>int</span> <span class=nx>y</span> <span class=o>=</span> <span class=nx>x</span> <span class=o>&gt;&gt;</span> <span class=nx>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// If y = 1, the fractional part is zero.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nx>y</span> <span class=o>!=</span> <span class=nx>scale</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Calculate the fractional part via the iterative approximation.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// The &#34;delta &gt;&gt;= 1&#34; part is equivalent to &#34;delta /= 2&#34;, but shifting bits is faster.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>loop</span> <span class=p>(</span><span class=mi>64</span><span class=p>)</span> <span class=o>:</span> <span class=nx>i</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>y</span> <span class=o>=</span> <span class=p>(</span><span class=nx>y</span> <span class=o>*</span> <span class=nx>y</span><span class=p>)</span> <span class=o>/</span> <span class=nx>scale</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// Is y^2 &gt; 2 and so in the range [2,4)?
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=nx>y</span> <span class=o>&gt;=</span> <span class=nx>scale</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Add the 2^(-m) factor to the logarithm.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kr>int</span> <span class=nx>delta</span> <span class=o>=</span> <span class=nx>scale</span> <span class=o>&gt;&gt;</span> <span class=p>(</span><span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nx>result</span> <span class=o>+=</span> <span class=nx>delta</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Corresponds to z/2 on Wikipedia.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>y</span> <span class=o>=</span> <span class=nx>y</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>From here, we can easily calculate the logarithm of other bases.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>static</span> <span class=kr>int</span> <span class=nx>ln2</span> <span class=o>=</span> <span class=mi>12786308645202657280</span><span class=p>;</span> <span class=c1>// log(x) * scale / log2(x)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>static</span> <span class=kr>int</span> <span class=nx>ln10</span> <span class=o>=</span> <span class=mi>5553023288523357184</span><span class=p>;</span> <span class=c1>// log10(x) * scale / log2(x)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kr>static</span> <span class=kd>function</span> <span class=nx>log</span><span class=p>(</span><span class=kr>int</span> <span class=nx>x</span><span class=p>)</span> <span class=o>:</span> <span class=kr>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>FixMath</span><span class=p>.</span><span class=nx>log2</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span> <span class=o>*</span> <span class=nx>FixMath</span><span class=p>.</span><span class=nx>ln2</span> <span class=o>/</span> <span class=nx>FixMath</span><span class=p>.</span><span class=nx>scale</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>static</span> <span class=kd>function</span> <span class=nx>log10</span><span class=p>(</span><span class=kr>int</span> <span class=nx>x</span><span class=p>)</span> <span class=o>:</span> <span class=kr>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>FixMath</span><span class=p>.</span><span class=nx>log2</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span> <span class=o>*</span> <span class=nx>FixMath</span><span class=p>.</span><span class=nx>ln10</span> <span class=o>/</span> <span class=nx>FixMath</span><span class=p>.</span><span class=nx>scale</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Next up is the exponentiation of base 2. This approximation works between -60 and 192.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>* Calculates the binary exponent of x using the binary fraction method.
</span></span></span><span class=line><span class=cl><span class=cm>* Accepts and returns scaled by 2**64 (64-bit fixed-point number).
</span></span></span><span class=line><span class=cl><span class=cm>* Adapted from https://github.com/paulrberg/prb-math
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kr>static</span> <span class=kd>function</span> <span class=nx>exp2</span><span class=p>(</span><span class=kr>int</span> <span class=nx>x</span><span class=p>)</span> <span class=o>:</span> <span class=kr>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>x</span> <span class=o>&gt;</span> <span class=mi>3541774862152233910272</span> <span class=o>||</span> <span class=nx>x</span> <span class=o>&lt;</span> <span class=o>-</span><span class=mi>1103017633157748883456</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 192 max value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// -59.794705707972522261 min value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>require</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Start from 0.5 in the 192.64-bit fixed-point format.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>int</span> <span class=nx>result</span> <span class=o>=</span> <span class=mh>0x800000000000000000000000000000000000000000000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// because the initial result is 2^191 and all magic factors are less than 2^65.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>((</span><span class=nx>x</span> <span class=o>&amp;</span> <span class=mh>0x8000000000000000</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span> <span class=o>=</span> <span class=p>(</span><span class=nx>result</span> <span class=o>*</span> <span class=mh>0x16a09e667f3bcc909</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>64</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>((</span><span class=nx>x</span> <span class=o>&amp;</span> <span class=mh>0x4000000000000000</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span> <span class=o>=</span> <span class=p>(</span><span class=nx>result</span> <span class=o>*</span> <span class=mh>0x1306fe0a31b7152df</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>64</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>((</span><span class=nx>x</span> <span class=o>&amp;</span> <span class=mh>0x2000000000000000</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span> <span class=o>=</span> <span class=p>(</span><span class=nx>result</span> <span class=o>*</span> <span class=mh>0x1172b83c7d517adce</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>64</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// Several similar lines removed for this example....
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>((</span><span class=nx>x</span> <span class=o>&amp;</span> <span class=mh>0x1</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span> <span class=o>=</span> <span class=p>(</span><span class=nx>result</span> <span class=o>*</span> <span class=mh>0x10000000000000001</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>64</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// We&#39;re doing two things at the same time:
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//   1. Multiply the result by 2^n + 1, where &#34;2^n&#34; is the integer part and the one is added to account for
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//      rather than 192.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//   2. Convert the result to the unsigned 60.18-decimal fixed-point format.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// This works because 2^(191-ip) = 2^ip / 2^191, where &#34;ip&#34; is the integer part &#34;2^n&#34;.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>result</span> <span class=o>=</span> <span class=nx>result</span> <span class=o>&lt;&lt;</span> <span class=mi>64</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>result</span> <span class=o>=</span> <span class=nx>result</span> <span class=o>&gt;&gt;</span> <span class=p>(</span><span class=mi>191</span> <span class=o>-</span> <span class=p>(</span><span class=nx>x</span> <span class=o>&gt;&gt;</span> <span class=mi>64</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now, we can easily derive the exponential function.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>static</span> <span class=kr>int</span> <span class=nx>log2e</span> <span class=o>=</span> <span class=mi>26613026195688644608</span><span class=p>;</span> <span class=c1>// Math.floor(Math.log2(Math.E) * 2**64)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>* Accepts and returns scaled by 2**64 (64-bit fixed-point number).
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kr>static</span> <span class=kd>function</span> <span class=nx>exp</span><span class=p>(</span><span class=kr>int</span> <span class=nx>x</span><span class=p>)</span> <span class=o>:</span> <span class=kr>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>x</span> <span class=o>&gt;</span> <span class=mi>2454971259878909673472</span> <span class=o>||</span> <span class=nx>x</span> <span class=o>&lt;</span> <span class=o>-</span><span class=mi>764553562531197616128</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Max value is 133.084258667509499441
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Min value is -41.446531673892822322
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>require</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>FixMath</span><span class=p>.</span><span class=nx>exp2</span><span class=p>((</span><span class=nx>x</span> <span class=o>*</span> <span class=nx>log2e</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>64</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Using exp and log, we can derive <code>root</code> and <code>pow</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>static</span> <span class=kd>function</span> <span class=nx>sqrt</span><span class=p>(</span><span class=kr>int</span> <span class=nx>x</span><span class=p>)</span> <span class=o>:</span> <span class=kr>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>exp2</span><span class=p>(</span><span class=nx>log2</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>static</span> <span class=kd>function</span> <span class=nx>root</span><span class=p>(</span><span class=kr>int</span> <span class=nx>x</span><span class=p>,</span> <span class=kr>int</span> <span class=nx>base</span><span class=p>)</span> <span class=o>:</span> <span class=kr>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>exp2</span><span class=p>((</span><span class=nx>log2</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>64</span><span class=p>)</span> <span class=o>/</span> <span class=nx>base</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>static</span> <span class=kd>function</span> <span class=nx>pow</span><span class=p>(</span><span class=kr>int</span> <span class=nx>base</span><span class=p>,</span> <span class=kr>int</span> <span class=nx>exp</span><span class=p>)</span> <span class=o>:</span> <span class=kr>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>exp2</span><span class=p>((</span><span class=nx>exp</span> <span class=o>*</span> <span class=nx>log2</span><span class=p>(</span><span class=nx>base</span><span class=p>))</span> <span class=o>&gt;&gt;</span> <span class=mi>64</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=how-big-are-the-scripts>How big are the Scripts?<a hidden class=anchor aria-hidden=true href=#how-big-are-the-scripts>#</a></h2><p>The exponential function is smallest with only <strong>8kb</strong>. The logarithm comes in with <strong>17kb</strong> while root and pow require <strong>25kb</strong> each as they are using <code>exp</code> and <code>log</code>. At 50 sats per kilobyte as currently offered by Taal, running the root or pow functions would set you back around 6/100 of a cent.</p><h2 id=vala>Vala<a hidden class=anchor aria-hidden=true href=#vala>#</a></h2><p>Vala uses <code>exp</code> and <code>log</code> in its automated market maker, namely the <a href=https://www.cultivatelabs.com/crowdsourced-forecasting-guide/how-does-logarithmic-market-scoring-rule-lmsr-work>Logarithmic Market Scoring Rule</a>. Without this, there could be no liquidity mechanism and the app would be unusable.</p><h2 id=the-library>The library<a hidden class=anchor aria-hidden=true href=#the-library>#</a></h2><p>The full library is open sourced on Github and contains a Typescript implementation of the same functions in addition to the sCrypt code so that you can actually generate valid transactions.</p><p><a href=https://github.com/valapm/bsv-fixmath>https://github.com/valapm/bsv-fixmath</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.vala.ai/tags/scrypt/>sCrypt</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
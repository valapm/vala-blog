<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Scaling scripts with Merkle Trees | Vala Blog</title><meta name=keywords content="sCrypt"><meta name=description content="A while back this article introduced the concept of minizing on-chain state through the usage of merkle tree validation in Bitcoin Script. At Vala, we use a version of this and now published an independent library for easy usage, validation and updating of merkle trees in Script.
Each prediction market in Vala has to track a ledger of balances in its current output. Without a mechanism to hide the ledger, this would lead to uncontrollable utxo growth."><meta name=author content="Merlin"><link rel=canonical href=https://blog.vala.ai/posts/merkletree/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.vala.ai/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://blog.vala.ai/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://blog.vala.ai/favicon.svg><link rel=apple-touch-icon href=https://blog.vala.ai/favicon.svg><link rel=mask-icon href=https://blog.vala.ai/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Scaling scripts with Merkle Trees"><meta property="og:description" content="A while back this article introduced the concept of minizing on-chain state through the usage of merkle tree validation in Bitcoin Script. At Vala, we use a version of this and now published an independent library for easy usage, validation and updating of merkle trees in Script.
Each prediction market in Vala has to track a ledger of balances in its current output. Without a mechanism to hide the ledger, this would lead to uncontrollable utxo growth."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.vala.ai/posts/merkletree/"><meta property="og:image" content="https://blog.vala.ai/tree.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-01T10:00:00+03:00"><meta property="article:modified_time" content="2022-11-01T10:00:00+03:00"><meta property="og:site_name" content="Vala Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.vala.ai/tree.jpg"><meta name=twitter:title content="Scaling scripts with Merkle Trees"><meta name=twitter:description content="A while back this article introduced the concept of minizing on-chain state through the usage of merkle tree validation in Bitcoin Script. At Vala, we use a version of this and now published an independent library for easy usage, validation and updating of merkle trees in Script.
Each prediction market in Vala has to track a ledger of balances in its current output. Without a mechanism to hide the ledger, this would lead to uncontrollable utxo growth."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.vala.ai/posts/"},{"@type":"ListItem","position":2,"name":"Scaling scripts with Merkle Trees","item":"https://blog.vala.ai/posts/merkletree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Scaling scripts with Merkle Trees","name":"Scaling scripts with Merkle Trees","description":"A while back this article introduced the concept of minizing on-chain state through the usage of merkle tree validation in Bitcoin Script. At Vala, we use a version of this and now published an independent library for easy usage, validation and updating of merkle trees in Script.\nEach prediction market in Vala has to track a ledger of balances in its current output. Without a mechanism to hide the ledger, this would lead to uncontrollable utxo growth.","keywords":["sCrypt"],"articleBody":"A while back this article introduced the concept of minizing on-chain state through the usage of merkle tree validation in Bitcoin Script. At Vala, we use a version of this and now published an independent library for easy usage, validation and updating of merkle trees in Script.\nEach prediction market in Vala has to track a ledger of balances in its current output. Without a mechanism to hide the ledger, this would lead to uncontrollable utxo growth.\nInstead, the ledger is hashed into a merkle tree and only the merkle root is contained in each utxo. If a trader wants to buy or sell shares, he has to provide a merkle proof to the script, proving his current balance. Similarly, if a new trader wants to add a new balance to the ledger, he has to provide the merkle proof for the last entry in the ledger to the script. From there, the new merkle root can be calculated.\nThis also means that to generate the entire ledger of balances, one has to go through all transactions of the market, looking at the changes in each input.\nHere are some examples:\nLet’s say we have 3 entries in our ledger.\nimport { getMerkleRoot, sha256d } from \"bsv-merkletree\"; const entries = [\"01\", \"02\", \"03\"]; const leafs = entries.map(sha256d); const merkleRoot = getMerkleRoot(leafs); Now let’s add another entry to it.\nimport { getMerklePath, addLeaf } from \"bsv-merkletree\"; const lastMerklePath = getMerklePath(2, leafs); const newMerkleRoot = addLeaf( \"03\", // last entry in the ledger lastMerklePath, merkleRoot, \"04\" // Our new entry ); To validate our update in Script, we have to provide the merkle proof/path and the new merkle root to it.\nimport \"./merkleTree.scrypt\"; bytes newCalculatedMerkleRoot = MerkleTree.addLeaf(b'03', lastMerklePath, merkleRoot, b'04'); require(newCalculatedMerkleRoot == newMerkleRoot); The library The full library is open sourced on Github and contains Typescript and sCrypt implementations.\nhttps://github.com/valapm/bsv-fixmath\nA critical vulnerability (Now fixed) Recently, NikamotoSV discovered a critical vulnerability in the merkle tree validation logic. The exploit even allowed for extraction of all funds out of the markets! The way it worked was smart: When providing a new entry for the ledger, it was possible to provide data that could be interpreted as a new branch in the merkle tree. That way one could spend fake shares by generating a merkle proof for the fake branch.\nNo money was lost and the exploit is fixed in market version 0.6.5.\n","wordCount":"399","inLanguage":"en","image":"https://blog.vala.ai/tree.jpg","datePublished":"2022-11-01T10:00:00+03:00","dateModified":"2022-11-01T10:00:00+03:00","author":{"@type":"Person","name":"Merlin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.vala.ai/posts/merkletree/"},"publisher":{"@type":"Organization","name":"Vala Blog","logo":{"@type":"ImageObject","url":"https://blog.vala.ai/favicon.svg"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://blog.vala.ai/ accesskey=h title="  (Alt + H)"><img src=https://blog.vala.ai/favicon.svg alt aria-label=logo height=35></a><div class=logo-switches></div></div><ul id=menu><li><a href=https://blog.vala.ai/index.xml title=rss><span>rss</span></a></li><li><a href=https://blog.vala.ai/tags title=tags><span>tags</span></a></li><li><a href=https://vala.ai title=vala.ai><span>vala.ai</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://docs.vala.ai title=docs><span>docs</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.vala.ai/>Home</a>&nbsp;»&nbsp;<a href=https://blog.vala.ai/posts/>Posts</a></div><h1 class=post-title>Scaling scripts with Merkle Trees</h1><div class=post-meta><span title='2022-11-01 10:00:00 +0300 +0300'>November 1, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;399 words&nbsp;·&nbsp;Merlin&nbsp;|&nbsp;<a href=https://github.com/valapm/vala-blog/content/posts/merkletree.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://blog.vala.ai/tree.jpg alt=tree></figure><div class=post-content><p>A while back <a href=https://xiaohuiliu.medium.com/scalable-state-storage-in-bsv-smart-contracts-60f9aeb3b1f>this article</a> introduced the concept of minizing on-chain state through the usage of merkle tree validation in Bitcoin Script. At Vala, we use a version of this and now published an independent <a href=https://github.com/valapm/bsv-merkletree>library</a> for easy usage, validation and updating of merkle trees in Script.</p><p>Each prediction market in Vala has to track a ledger of balances in its current output. Without a mechanism to hide the ledger, this would lead to uncontrollable utxo growth.</p><p>Instead, the ledger is hashed into a merkle tree and only the merkle root is contained in each utxo. If a trader wants to buy or sell shares, he has to provide a merkle proof to the script, proving his current balance. Similarly, if a new trader wants to add a new balance to the ledger, he has to provide the merkle proof for the last entry in the ledger to the script. From there, the new merkle root can be calculated.</p><p>This also means that to generate the entire ledger of balances, one has to go through all transactions of the market, looking at the changes in each input.</p><p>Here are some examples:</p><p>Let&rsquo;s say we have 3 entries in our ledger.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span> <span class=nx>getMerkleRoot</span><span class=p>,</span> <span class=nx>sha256d</span> <span class=p>}</span> <span class=kr>from</span> <span class=s2>&#34;bsv-merkletree&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>entries</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;01&#34;</span><span class=p>,</span> <span class=s2>&#34;02&#34;</span><span class=p>,</span> <span class=s2>&#34;03&#34;</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>leafs</span> <span class=o>=</span> <span class=nx>entries</span><span class=p>.</span><span class=nx>map</span><span class=p>(</span><span class=nx>sha256d</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>merkleRoot</span> <span class=o>=</span> <span class=nx>getMerkleRoot</span><span class=p>(</span><span class=nx>leafs</span><span class=p>);</span>
</span></span></code></pre></div><p>Now let&rsquo;s add another entry to it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span> <span class=nx>getMerklePath</span><span class=p>,</span> <span class=nx>addLeaf</span> <span class=p>}</span> <span class=kr>from</span> <span class=s2>&#34;bsv-merkletree&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>lastMerklePath</span> <span class=o>=</span> <span class=nx>getMerklePath</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=nx>leafs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>newMerkleRoot</span> <span class=o>=</span> <span class=nx>addLeaf</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;03&#34;</span><span class=p>,</span> <span class=c1>// last entry in the ledger
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>lastMerklePath</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>merkleRoot</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;04&#34;</span> <span class=c1>// Our new entry
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span>
</span></span></code></pre></div><p>To validate our update in Script, we have to provide the merkle proof/path and the new merkle root to it.</p><pre tabindex=0><code class=language-sCrypt data-lang=sCrypt>import &#34;./merkleTree.scrypt&#34;;

bytes newCalculatedMerkleRoot = MerkleTree.addLeaf(b&#39;03&#39;, lastMerklePath, merkleRoot, b&#39;04&#39;);

require(newCalculatedMerkleRoot == newMerkleRoot);
</code></pre><h2 id=the-library>The library<a hidden class=anchor aria-hidden=true href=#the-library>#</a></h2><p>The full library is open sourced on Github and contains Typescript and <a href=https://scrypt.io/>sCrypt</a> implementations.</p><p><a href=https://github.com/valapm/bsv-fixmath>https://github.com/valapm/bsv-fixmath</a></p><h2 id=a-critical-vulnerability-now-fixed>A critical vulnerability (Now fixed)<a hidden class=anchor aria-hidden=true href=#a-critical-vulnerability-now-fixed>#</a></h2><p>Recently, <a href=https://twitter.com/NikamotoS>NikamotoSV</a> discovered a <a href=https://nikamotosv.substack.com/p/your-type-is-not-type>critical vulnerability</a> in the merkle tree validation logic. The exploit even allowed for extraction of all funds out of the markets! The way it worked was smart: When providing a new entry for the ledger, it was possible to provide data that could be interpreted as a new branch in the merkle tree. That way one could spend fake shares by generating a merkle proof for the fake branch.</p><p>No money was lost and the exploit is fixed in market version 0.6.5.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.vala.ai/tags/scrypt/>sCrypt</a></li></ul><nav class=paginav><a class=next href=https://blog.vala.ai/posts/fixmath/><span class=title>Next »</span><br><span>Advanced Arithmetic in Bitcoin Script</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>